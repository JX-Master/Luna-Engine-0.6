// Copyright 2018-2020 JXMaster. All rights reserved.
/*
* @file IDrawList.hpp
* @author JXMaster
* @date 2019/10/5
*/
#pragma once
#include <Core/IObject.hpp>
#include <Gfx/IResource.hpp>
#include <Runtime/Math.hpp>
#include "IFontTexture.hpp"
#include <Gfx/Views.hpp>

namespace Luna
{
	namespace EasyDraw
	{
		//! Defines a vertex generated by draw list.
		struct PrimitiveVertex
		{
			//! The position of the vertex in screen space (starts from top left).
			Float2U pos;
			//! The uv coordinate to use when sampling textures.
			Float2U uv;
			//! The color of the vertex. This will be multiplied with sampled texture color.
			Float4U color;
		};

		//! Defines a draw call batched by the draw list.
		//! All pointers in the structure is valid until another draw command is pushed. You should either
		//! get the draw call after you have pushed all commands into the list, or stop pushing commands
		//! when you use the draw call.
		struct DrawCall
		{
			Gfx::IResource* texture;
			const PrimitiveVertex* vertices;
			const u32* indices;
			u32 num_vertices;
			u32 num_indices;
			Gfx::SamplerDesc sampler;
			f32 rotation;
			f32 origin_x;
			f32 origin_y;
			RectI clip_rect;
		};

		struct TextDrawResult
		{
			//! The real width used to render the text.
			f32 region_width;
			//! The real height used to render the text.
			f32 region_height;
			//! `true` if the region is two small that cannot hold all characters.
			//! `false` otherwise.
			bool overflow;
		};

		enum class EDrawListAppendFlag : u32
		{
			none = 0,
			//! The data is copied to this draw list rather than moved. If the data is moved, the 
			//! draw list where the data comes from will be empty after appending.
			copy_data = 1,
			//! Inherits the current transform (offset and rotation) when appending elements in the 
			//! draw list. For example, if the offset and rotation for the appended data is (10.0, 5.0, 90.0),
			//! and the current rotation set by last `get_origin` and `set_rotation` is (-2.0, -8.0, 90.0),
			//! then the final origin point and rotation will be (8.0, -3.0, 180.0).
			inherit_transform = 2,
		};

		//! @interface IDrawList
		//! IDrawList batches a series of draw commands into several draw calls
		//! to the graphic device. The draw list is independent with specific 
		//! render targets and render devices, so it can store commands that 
		//! can be written to any surface.
		struct IDrawList : public IObject
		{
			luiid("{50f877ad-8b7c-4437-9fd7-a442bdf4afd0}");

			//! Reset the draw list. This call clears all data stored in the draw
			//! list and reset all its parameters.
			virtual void reset() = 0;

			//! Makes the following drawing commands not to be appended to the draw calls that are created before this method
			//! is called.
			//! 
			//! @remark An draw list manages a series of draw calls. Each of the draw calls is bound to a specific pipeline state 
			//! set (like texture, sampler, transform and so on) and will be sent to the GPU as one real draw call. All elements 
			//! that shares the same draw pipeline state will be batched into one draw call, when a new shape is added to the draw list, 
			//! the draw list finds the draw call that matches the current pipeline setting and appends this shape's primitives into the 
			//! draw call. If no draw call is found, the draw list creates a new draw call and pushes the new shape into the new draw call. 
			//! 
			//! This sometimes can be a problem because after batching, one shape that is drawn lately may be batched into one draw call that 
			//! is created early, thus gets drawn early by GPU. If two shapes are batched into the same draw call (because they have exactly the same
			//! drawing settings), this will not be a problem, because the hardware guarantees the later added shapes are always drawn later. But if 
			//! two shapes are not batched into the same draw call (because they have different drawing settings), the drawing order of the shapes depends on 
			//! the drawing order of their draw calls, which is sometimes unpredictable.
			//! 
			//! When `drawcall_barrier` is called, the draw list prevents the later added shapes to be batched to previously created draw calls,
			//! so that they will be guaranteed to be drawn after all draw calls before `drawcall_barrier` get drawn. Using this, the draw list assumes that all 
			//! commands drawn later have chances to occlude previously drawn elements, so there is no chance of batching them with previously draw calls 
			//! (even if they do have).
			//! 
			//! `drawcall_barrier` will be called by draw list internally when another draw list is appended to this draw list by calling `append_draw_list`.
			virtual void drawcall_barrier() = 0;

			//! Sets the texture to be sampled when rendering the succeeding shapes.
			//! @param[in] tex The texture to set. Specify `nullptr` is allowed, its behavior is defined by the renderer. usually means using a pure white
			//! texture with value (1.0, 1.0, 1.0, 1.0).
			//! @remark The draw list only stores the texture and its state as-is and provides it to the renderer 
			//! when the draw list is processed by the renderer. It does not do any validation to the texture and 
			//! its states. It is the user and renderer's responsibility to validate the texture and its state.
			//! 
			//! The draw list has texture being set to `nullptr` after reset.
			virtual void set_texture(Gfx::IResource* tex) = 0;

			//! Gets the currently set texture, returns `nullptr` if no texture is set.
			virtual Gfx::IResource* get_texture() = 0;

			//! Sets the sampler state to be used when sampling bound textures.
			//! Specify `nullptr` to reset the sampler state to initial settings.
			virtual void set_sampler(const Gfx::SamplerDesc* desc) = 0;

			//! Gets the sampler state currently set.
			virtual void get_sampler(Gfx::SamplerDesc* desc) = 0;

			//! Gets the currently set font texture. Returns `nullptr` if no custom font is set.
			virtual IFontTexture* get_font() = 0;

			//! Sets the current font texture.
			virtual void set_font(IFontTexture* font_texture) = 0;

			//! Sets the origin point for the following draw calls.
			//! The origin point is relative to the top-left origin point of the canvas. For example, if the position of the vertex
			//! is (3.0f, 5.0f) and origin point is (6.0f, 1.0f), then the final position of the point will be (9.0f, 6.0f) relative
			//! to the top-left origin of the canvas (render target).
			//! 
			//! The origin point of the canvas is the top-left corner of the render target. The x axis points to right and the y 
			//! axis points to down.
			//! 
			//! The origin point is (0,0) when the draw list has been reset.
			//! @param[in] offset The x and y offset in pixels.
			virtual void set_origin(const Float2& origin) = 0;

			//! Gets the origin point for the following draw calls.
			virtual void get_origin(Float2& origin) = 0;

			//! Sets the rotation for the following draw calls, the rotation is relative to the set origin point.
			//! The rotation is specified in degrees and clockwise.
			virtual void set_rotation(f32 degrees) = 0;

			//! Gets the rotation for the following draw calls.
			virtual f32 get_rotation() = 0;

			//! Sets the clip rect for the following calls, any draw call that goes out of clip region will be clipped.
			//! @param[in] clip_rect The clip rect to set. The rect position is relative to the point set by `set_offset`.
			//! Default clip rect is (0,0,0,0) and it should mean no clip for the renderer.
			//! 
			//! The clip rect will not be rotated by `set_rotation`.
			virtual void set_clip_rect(const RectI& clip_rect = RectI(0,0,0,0)) = 0;

			//! Gets the clip rect for the following calls.
			virtual void get_clip_rect(RectI& clip_rect) = 0;

			//! Copies or moves the data from the provided draw list and appends the data into this draw list.
			//! @param[in] draw_list The draw list that the data is from.
			//! @param[in] flags Additional flags specifying how to append the data.
			virtual void append_draw_list(IDrawList* draw_list, EDrawListAppendFlag flags = EDrawListAppendFlag::none) = 0;

			//! Draws a primitive triangle list.
			//! The list is described with vertices and indices with three of indices refer to a triangle.
			//! This is the primitive method for all of the other draw operations.
			virtual void draw_triangle_list(u32 num_vertices, const PrimitiveVertex* vertices,
				u32 num_indices, const u32* indices) = 0;

			//! Draws a text string.
			//! The text will be drawn from top to down and from left to right.
			//! The font texture will be set as the sample texture, and the text coordinate information will be written 
			//! into the vertex data.
			//! If no font texture is bound using `set_font` before, this call fails.
			//! @param[in] text The UTF-8 text string to draw.
			//! @param[in] top_left The top-left point of the text region (<top, left>).
			//! @param[in] region_size The size of the region (<width, height>) to draw the text into. 
			//! Specifying 0.0f to width or height means unbound region.
			//! @param[in] col The color used to draw text.
			//! @param[in] spacing Specifies the spacing between each characters and each rows.
			virtual R<TextDrawResult> draw_text(const char* text, const Float2& top_left, const Float2& region_size, 
				const Float4& col = Color::white, const Float2& spacing = Float2(0.0f, 0.0f)) = 0;

			//! Draws a filled triangle.
			virtual void draw_triangle_filled(const Float2& p1, const Float2& p2, const Float2& p3, const Float4& col, bool antialiased = true) = 0;

			//! Draws a bordered triangle.
			virtual void draw_triangle_bordered(const Float2& p1, const Float2& p2, const Float2& p3, const Float4& col, f32 line_width, bool antialiased = true) = 0;

			//! Draws a filled rectangle.
			virtual void draw_rectangle_filled(const Float2& top_left, const Float2& size, const Float4& col) = 0;

			//! Draws a bordered rectangle.
			virtual void draw_rectangle_bordered(const Float2& top_left, const Float2& size, const Float4& col, f32 line_width) = 0;

			//! Draws a filled circle.
			virtual void draw_circle_filled(const Float2& center, f32 radius, const Float4& col, bool antialiased = true, u32 num_segments = 16) = 0;

			//! Draws a bordered circle.
			virtual void draw_circle_bordered(const Float2& center, f32 radius, const Float4& col, f32 line_width, bool antialiased = true, u32 num_segments = 16) = 0;

			//! Draws a filled rounded edge rect.
			virtual void draw_rounded_rectangle_filled(const Float2& top_left, const Float2& size, const Float4& col, f32 round_radius, bool antialiased = true) = 0;

			//! Draws a bordered round edge rect.
			virtual void draw_rounded_rectangle_bordered(const Float2& top_left, const Float2& size, const Float4& col, f32 round_radius, f32 line_width, bool antialiased = true) = 0;

			//! Draws a line.
			virtual void draw_line(const Float2& pos1, const Float2& pos2, const Float4& col, f32 line_width, bool antialiased = true) = 0;

			//! Draws an image.
			virtual void draw_texture(const Float2& top_left, const Float2& size, const Float4& tint, Gfx::IResource* tex, Gfx::EResourceState state, const Float2& top_left_uv = Float2(0.0f, 0.0f), const Float2& bottom_right_uv = Float2(1.0f, 1.0f)) = 0;

			//! Get the number of draw calls currently stored in the draw list.
			virtual u32 count_draw_calls() = 0;

			//! Enumerates draw calls.
			//! @param[in] index The index to enumerate. This must be in range [0, count_draw_calls()),
			//! or the behavior is undefined.
			virtual void enum_draw_call(u32 index, DrawCall& dc) = 0;
		};
	}
}